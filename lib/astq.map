{"version":3,"file":"bundle.js","sources":["node_modules/grunt-browserify/node_modules/browserify/node_modules/browser-pack/_prelude.js","src/astq-adapter-xmldom.js","src/astq-adapter-mozast.js","src/astq-adapter.js","src/astq-query-trace.js","src/astq-funcs-std.js","src/astq-query-exec.js","src/astq-adapter-asty.js","src/astq-query.js","src/astq-cache.js","src/astq-util.js","src/astq.js","src/astq-funcs.js","node_modules/pegjs-util/PEGUtil.js"],"names":["ASTQAdapterXMLDOM","taste","node","Node","nodeType","nodeName","getParentNode","parentNode","getChildNodes","childNodes","getNodeType","getNodeAttrNames","Array","prototype","slice","call","attributes","map","n","getNodeAttrValue","attr","getAttribute","module","exports","ASTQAdapterMozAST","type","loc","Error","childs","field","hasOwnProperty","this","push","forEach","_this","names","undefined","ASTQAdapter","_adapters","register","adapter","select","i","length","util","require","ASTQQueryTrace","prefixOf","Q","T","depth","parent","prefix1","pad","prefix2","traceBegin","trace","_prefixOf","console","log","traceEnd","val","_prefixOf2","result","replace","substr","stdfuncs","A","pos","pchilds","nth","num","parseInt","first","last","count","Object","keys","String","str","len","lc","toLowerCase","uc","toUpperCase","ASTQQueryExec","params","funcs","execQuery","output","concat","execPath","nodes","_this2","execStep","axis","match","filter","id","get","matchAndTake","_this3","take","execFilter","op","walk","leftSibling","_i","_i2","_i3","_i4","expr","execExpr","truthy","execExprConditionalBinary","execExprConditionalTernary","execExprLogical","execExprBitwise","execExprRelational","execExprArithmetical","execExprUnary","execExprFuncCall","execExprAttribute","execExprParam","execExprLiteralString","execExprLiteralRegExp","execExprLiteralNumber","execExprLiteralValue","execExprPath","v1","coerce","v2","Math","pow","v","args","_this4","run","ASTQAdapterASTY","ASTy","attrs","ASTY","window","global","PEGUtil","ASTQQueryParse","peg$subclass","child","ctor","constructor","SyntaxError","message","expected","found","offset","line","column","name","peg$FAILED","peg$startRuleFunctions","query","peg$parsequery","peg$startRuleFunction","peg$c3","peg$c4","value","description","peg$c5","f","l","ast","add","unroll","a","m","peg$c10","ASTQCache","_index","_oldHead","newer","_newHead","older","_cur","_max","Infinity","_dispose","limit","max","maxOld","arguments","_purge","dispose","cb","each","key","values","ctx","bucket","has","peek","expires","Date","now","del","touch","_promote","set","_attach","valOld","_detach","clear","ASTQUtil","join","isNaN","Boolean","Number","RegExp","e","ASTQFuncs","ASTQQuery","ASTQ","_adapter","_funcs","_cache","func","cache","entries","compile","selector","execute","apply","root","factory","define","amd","makeAST","options","__makeAST","makeUnroll","list","j","unshift","excerpt","txt","o","b","hex","ch","charCodeAt","toString","extract","prolog","token","epilog","parse","parser","error","opts","startRule","definedOrElse","fallback","location","errorMessage","noFinalNewline","msg"],"mappings":"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","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nlet ASTQAdapterXMLDOM = {\n    taste (node) {\n        /* global Node: true */\n        return (\n               typeof Node === \"object\"\n            && node instanceof Node\n            && typeof node === \"object\"\n            && typeof node.nodeType === \"number\"\n            && typeof node.nodeName === \"string\"\n        )\n    },\n    getParentNode (node) {\n        return node.parentNode\n    },\n    getChildNodes (node) {\n        return node.childNodes\n    },\n    getNodeType (node) {\n        return node.nodeName\n    },\n    getNodeAttrNames (node) {\n        return Array.prototype.slice.call(node.attributes, 0)\n            .map((n) => n.nodeName)\n    },\n    getNodeAttrValue (node, attr) {\n        return node.getAttribute(attr)\n    }\n}\n\nmodule.exports = ASTQAdapterXMLDOM\n\n","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*  See also: https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API  */\n\nlet ASTQAdapterMozAST = {\n    taste (node) {\n        return (\n               typeof node      === \"object\"\n            && typeof node.type === \"string\"\n            && typeof node.loc  === \"object\"\n        )\n    },\n    getParentNode (/* node */) {\n        throw new Error(\"Mozilla SpiderMonkey AST does not support parent node traversal\")\n    },\n    getChildNodes (node) {\n        let childs = []\n        for (let field in node) {\n            if (   node.hasOwnProperty(field)\n                && this.taste(node[field]))\n                childs.push(node)\n            else if (   node.hasOwnProperty(field)\n                     && typeof node[field] === \"object\"\n                     && node[field] instanceof Array) {\n                node[field].forEach((node) => {\n                    if (this.taste(node))\n                       childs.push(node)\n                })\n            }\n        }\n        return childs\n    },\n    getNodeType (node) {\n        return node.type\n    },\n    getNodeAttrNames (node) {\n        let names = []\n        for (let field in node)\n            if (   node.hasOwnProperty(field)\n                && typeof node[field] !== \"object\"\n                && field !== \"type\"\n                && field !== \"loc\")\n                names.push(field)\n        return names\n    },\n    getNodeAttrValue (node, attr) {\n        if (   node.hasOwnProperty(attr)\n            && typeof node[attr] !== \"object\"\n            && attr !== \"type\"\n            && attr !== \"loc\")\n            return node[attr]\n        else\n            return undefined\n    }\n}\n\nmodule.exports = ASTQAdapterMozAST\n\n","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nclass ASTQAdapter {\n    constructor () {\n        this._adapters = []\n        return this\n    }\n    register (adapter) {\n        this._adapters.push(adapter)\n    }\n    select (node) {\n        for (let i = 0; i < this._adapters.length; i++)\n            if (this._adapters[i].taste(node))\n                return this._adapters[i]\n        return undefined\n    }\n}\n\nmodule.exports = ASTQAdapter\n\n","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nlet util = require(\"./astq-util.js\")\n\nlet ASTQQueryTrace = class ASTQQueryTrace {\n    prefixOf (Q, T) {\n        let depth = 0\n        let node = Q\n        while ((node = node.parent()) !== null)\n            depth++\n        let prefix1 = util.pad(\"\", 4 * depth)\n\n        depth = 0\n        let node = T\n        while ((node = this.adapter.getParentNode(node)) !== null)\n            depth++\n        let prefix2 = util.pad(\"\", 4 * depth)\n\n        return { prefix1, prefix2 }\n    }\n\n    traceBegin (Q, T) {\n        if (!this.trace)\n            return\n        let { prefix1, prefix2 } = this.prefixOf(Q, T)\n        console.log(\"ASTQ: execute: | \" +\n            util.pad(prefix1 + Q.type() + \" (\", -60) + \" | \" +\n            prefix2 + this.adapter.getNodeType(T))\n    }\n\n    traceEnd (Q, T, val) {\n        if (!this.trace)\n            return\n        let { prefix1, prefix2 } = this.prefixOf(Q, T)\n        let result\n        if (val === undefined)\n            result = \"undefined\"\n        else if (typeof val === \"object\" && val instanceof Array) {\n            result = \"[\"\n            val.forEach((node) => {\n                result += \"node(\" + this.adapter.getNodeType(node) + \"),\"\n            })\n            result = result.replace(/,$/, \"\") + \"]\"\n        }\n        else\n            result = typeof val + \"(\" + val + \")\"\n        if (result.length > 60)\n            result = result.substr(0, 60) + \"...\"\n        console.log(\"ASTQ: execute: | \" +\n            util.pad(prefix1 + \"): \" + result, -60) + \" | \" +\n            prefix2 + this.adapter.getNodeType(T))\n    }\n}\n\nmodule.exports = ASTQQueryTrace\n","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nlet stdfuncs = {\n    /*  type name of node  */\n    \"type\": (A, T) => {\n        return A.getNodeType(T)\n    },\n\n    /*  depth of node in tree  */\n    \"depth\": (A, T) => {\n        let depth = 1\n        let node = T\n        while ((node = A.getParentNode(node)) !== null)\n            depth++\n        return depth\n    },\n\n    /*  return position of node between siblings  */\n    \"pos\": (A, T) => {\n        let parent = A.getParentNode(T)\n        if (parent === null)\n            return 1\n        let pchilds = A.getChildNodes(parent)\n        for (let i = 0; i < pchilds.length; i++)\n            if (pchilds[i] === T)\n                return (i + 1)\n        throw new Error(\"cannot find myself\") \n    },\n\n    /*  check position of node between siblings  */\n    \"nth\": (A, T, num) => {\n        num = parseInt(num, 10)\n        let parent = A.getParentNode(T)\n        if (parent !== null) {\n            let pchilds = A.getChildNodes(parent)\n            if (num < 0)\n                num = pchilds - (num + 1);\n            for (let i = 0; i < pchilds.length; i++)\n                if (pchilds[i] === T)\n                    return ((i + 1) === num)\n            return false\n        }\n        else if (num === 1)\n            return true\n        else\n            return false\n    },\n\n    /*  check position of node to be first of siblings  */\n    \"first\": (A, T) => {\n        return stdfuncs.nth(A, T, 1)\n    },\n\n    /*  check position of node to be last of siblings  */\n    \"last\": (A, T) => {\n        return stdfuncs.nth(A, T, -1)\n    },\n\n    /*  count number of keys/elements/characters/etc  */\n    \"count\": (A, T, val) => {\n        if (typeof val === \"object\" && val instanceof Array)\n            return val.length\n        else if (typeof val === \"object\")\n            return Object.keys(val).length\n        else if (typeof val === \"string\")\n            return val.length\n        else\n            return String(val).length\n    },\n\n    /*  retrieve a sub-string  */\n    \"substr\": (A, T, str, pos, len) => {\n        return String(str).substr(pos, len)\n    },\n\n    /*  convert string to lower-case  */\n    \"lc\": (A, T, str) => {\n        return String(str).toLowerCase()\n    },\n\n    /*  convert string to upper-case  */\n    \"uc\": (A, T, str) => {\n        return String(str).toUpperCase()\n    }\n}\n\nmodule.exports = stdfuncs\n","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nlet util          = require(\"./astq-util.js\")\nlet ASTQQueryTrace = require(\"./astq-query-trace.js\")\n\nlet ASTQQueryExec = class ASTQQueryExec extends ASTQQueryTrace {\n    constructor (adapter, params, funcs, trace) {\n        this.adapter = adapter\n        this.params  = params\n        this.funcs   = funcs\n        this.trace   = trace\n    }\n\n    execQuery (Q, T) {\n        this.traceBegin(Q, T)\n        let output = []\n        Q.childs().forEach((Q) => {\n            output = output.concat(this.execPath(Q, T))\n        })\n        this.traceEnd(Q, T, output)\n        return output\n    }\n\n    execPath (Q, T) {\n        this.traceBegin(Q, T)\n        let nodes = [ T ]\n        Q.childs().forEach((Q) => {\n            let output = []\n            nodes.forEach((T) => {\n                output = output.concat(this.execStep(Q, T))\n            })\n            nodes = output\n        })\n        this.traceEnd(Q, T, nodes)\n        return nodes\n    }\n\n    execStep (Q, T) {\n        this.traceBegin(Q, T)\n\n        /*  determine (optional) axis, (mandatory) match and (optional) filter  */\n        let childs = Q.childs()\n        let axis   = null\n        let match  = null\n        let filter = null\n        let i = 0\n        if (i < childs.length && childs[i].type() === \"Axis\")\n            axis = childs[i++]\n        if (i < childs.length && childs[i].type() === \"Match\")\n            match = childs[i++]\n        if (i < childs.length && childs[i].type() === \"Filter\")\n            filter = childs[i++]\n        if (match === null)\n            throw new Error(\"no matching part in query step\")\n\n        let nodes = []\n\n        /*  helper function for matching and taking node  */\n        let id = match.get(\"id\")\n        let matchAndTake = (T) => {\n            let type = this.adapter.getNodeType(T)\n            if (id === \"*\" || id === type) {\n                let take = true\n                if (filter !== null)\n                    if (!this.execFilter(filter, T))\n                        take = false\n                if (take)\n                    nodes.push(T)\n            }\n        }\n\n        /*  determine nodes along axis which potentially might match  */\n        if (axis !== null) {\n            let op = axis.get(\"op\")\n            if (op === \"/\") {\n                /*  direct child nodes  */\n                this.adapter.getChildNodes(T).forEach((T) => matchAndTake(T))\n            }\n            else if (op === \"//\") {\n                /*  transitive child nodes  */\n                let walk = (T) => {\n                    matchAndTake(T)\n                    this.adapter.getChildNodes(T).forEach((T) => walk(T)) /* RECURSION */\n                }\n                this.adapter.getChildNodes(T).forEach((T) => walk(T))\n            }\n            else if (op === \"<~\") {\n                /*  direct left sibling  */\n                let parent = this.adapter.getParentNode(T)\n                if (parent !== null) {\n                    let pchilds = this.adapter.getChildNodes(parent)\n                    let leftSibling = null\n                    for (let i = 0; i < pchilds.length; i++) {\n                        if (pchilds[i] === T)\n                            break\n                        leftSibling = pchilds[i]\n                    }\n                    matchAndTake(leftSibling)\n                }\n            }\n            else if (op === \"<~~\") {\n                /*  transitive left siblings  */\n                let parent = this.adapter.getParentNode(T)\n                if (parent !== null) {\n                    let pchilds = this.adapter.getChildNodes(parent)\n                    for (let i = 0; i < pchilds.length; i++) {\n                        if (pchilds[i] === T)\n                            break\n                        matchAndTake(pchilds[i])\n                    }\n                }\n            }\n            else if (op === \"~>\") {\n                /*  direct right sibling  */\n                let parent = this.adapter.getParentNode(T)\n                if (parent !== null) {\n                    let pchilds = this.adapter.getChildNodes(parent)\n                    let i\n                    for (i = 0; i < pchilds.length; i++)\n                        if (pchilds[i] === T)\n                            break\n                    if (i < pchilds.length) {\n                        i++\n                        matchAndTake(pchilds[i])\n                    }\n                }\n            }\n            else if (op === \"~~>\") {\n                /*  transitive right siblings  */\n                let parent = this.adapter.getParentNode(T)\n                if (parent !== null) {\n                    let pchilds = this.adapter.getChildNodes(parent)\n                    let i\n                    for (i = 0; i < pchilds.length; i++)\n                        if (pchilds[i] === T)\n                            break\n                    if (i < pchilds.length) {\n                        i++\n                        while (i < pchilds.length)\n                            matchAndTake(pchilds[i++])\n                    }\n                }\n            }\n            else if (op === \"~^\") {\n                /*  direct parent  */\n                let parent = this.adapter.getParentNode(T)\n                if (parent !== null)\n                    matchAndTake(parent)\n            }\n            else if (op === \"~~^\") {\n                /*  transitive parents  */\n                let node = T\n                while (true) {\n                    let parent = this.adapter.getParentNode(node)\n                    if (parent === null)\n                        break\n                    matchAndTake(parent)\n                    node = parent\n                }\n            }\n        }\n        else\n            /*  current node  */\n            matchAndTake(T)\n\n        this.traceEnd(Q, T, nodes)\n        return nodes\n    }\n\n    execFilter (Q, T) {\n        this.traceBegin(Q, T)\n        let expr = Q.childs()[0]\n        let result = this.execExpr(expr, T)\n        result = util.truthy(result)\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExpr (Q, T) {\n        switch (Q.type()) {\n            case \"ConditionalBinary\":  return this.execExprConditionalBinary (Q, T)\n            case \"ConditionalTernary\": return this.execExprConditionalTernary(Q, T)\n            case \"Logical\":            return this.execExprLogical           (Q, T)\n            case \"Bitwise\":            return this.execExprBitwise           (Q, T)\n            case \"Relational\":         return this.execExprRelational        (Q, T)\n            case \"Arithmetical\":       return this.execExprArithmetical      (Q, T)\n            case \"Unary\":              return this.execExprUnary             (Q, T)\n            case \"FuncCall\":           return this.execExprFuncCall          (Q, T)\n            case \"Attribute\":          return this.execExprAttribute         (Q, T)\n            case \"Param\":              return this.execExprParam             (Q, T)\n            case \"LiteralString\":      return this.execExprLiteralString     (Q, T)\n            case \"LiteralRegExp\":      return this.execExprLiteralRegExp     (Q, T)\n            case \"LiteralNumber\":      return this.execExprLiteralNumber     (Q, T)\n            case \"LiteralValue\":       return this.execExprLiteralValue      (Q, T)\n            case \"Path\":               return this.execExprPath              (Q, T)\n        }\n    }\n\n    execExprConditionalBinary (Q, T) {\n        this.traceBegin(Q, T)\n        let result = this.execExpr(Q.childs()[0], T)\n        if (!util.truthy(result))\n            result = this.execExpr(Q.childs()[1], T)\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprConditionalTernary (Q, T) {\n        this.traceBegin(Q, T)\n        let result = this.execExpr(Q.childs()[0], T)\n        if (util.truthy(result))\n            result = this.execExpr(Q.childs()[1], T)\n        else\n            result = this.execExpr(Q.childs()[2], T)\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprLogical (Q, T) {\n        this.traceBegin(Q, T)\n        let result = false\n        switch (Q.get(\"op\")) {\n            case \"&&\":\n                result = util.truthy(this.execExpr(Q.childs()[0], T))\n                if (result)\n                    result = result && util.truthy(this.execExpr(Q.childs()[1], T))\n                break\n            case \"||\":\n                result = util.truthy(this.execExpr(Q.childs()[0], T))\n                if (!result)\n                    result = result || util.truthy(this.execExpr(Q.childs()[1], T))\n                break\n        }\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprBitwise (Q, T) {\n        this.traceBegin(Q, T)\n        let v1 = util.coerce(this.execExpr(Q.childs()[0], T), \"number\")\n        let v2 = util.coerce(this.execExpr(Q.childs()[1], T), \"number\")\n        let result\n        switch (Q.get(\"op\")) {\n            case \"&\":  result = v1 &  v2; break\n            case \"|\":  result = v1 |  v2; break\n            case \"<<\": result = v1 << v2; break\n            case \">>\": result = v1 >> v2; break\n        }\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprRelational (Q, T) {\n        this.traceBegin(Q, T)\n        let v1 = this.execExpr(Q.childs()[0], T)\n        let v2 = this.execExpr(Q.childs()[1], T)\n        let result\n        switch (Q.get(\"op\")) {\n            case \"==\": result = v1 === v2; break\n            case \"!=\": result = v1 !== v2; break\n            case \"<=\": result = util.coerce(v1, \"number\") <= util.coerce(v2, \"number\"); break\n            case \">=\": result = util.coerce(v1, \"number\") >= util.coerce(v2, \"number\"); break \n            case \"<\":  result = util.coerce(v1, \"number\") <  util.coerce(v2, \"number\"); break\n            case \">\":  result = util.coerce(v1, \"number\") >  util.coerce(v2, \"number\"); break\n            case \"=~\": result = util.coerce(v1, \"string\").match(util.coerce(v2, \"regexp\")) !== null; break\n            case \"!~\": result = util.coerce(v1, \"string\").match(util.coerce(v2, \"regexp\")) === null; break\n        }\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprArithmetical (Q, T) {\n        this.traceBegin(Q, T)\n        let v1 = this.execExpr(Q.childs()[0], T)\n        let v2 = this.execExpr(Q.childs()[1], T)\n        let result\n        switch (Q.get(\"op\")) {\n            case \"+\":\n                if (typeof v1 === \"string\")\n                    result = v1 + util.coerce(v2, \"string\")\n                else\n                    result = util.coerce(v1, \"number\") + util.coerce(v2, \"number\")\n                break\n            case \"-\":  result = util.coerce(v1, \"number\") + util.coerce(v2, \"number\"); break\n            case \"*\":  result = util.coerce(v1, \"number\") * util.coerce(v2, \"number\"); break\n            case \"/\":  result = util.coerce(v1, \"number\") / util.coerce(v2, \"number\"); break\n            case \"%\":  result = util.coerce(v1, \"number\") % util.coerce(v2, \"number\"); break\n            case \"**\": result = Math.pow(util.coerce(v1, \"number\"), util.coerce(v2, \"number\")); break\n        }\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprUnary (Q, T) {\n        this.traceBegin(Q, T)\n        let v = this.execExpr(Q.childs()[0], T)\n        let result\n        switch (Q.get(\"op\")) {\n            case \"!\": result = !util.coerce(v, \"boolean\"); break\n            case \"~\": result = ~util.coerce(v, \"number\");  break\n        }\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprFuncCall (Q, T) {\n        this.traceBegin(Q, T)\n        let id = Q.get(\"id\")\n        let args = [ this.adapter, T ]\n        Q.childs().forEach((Q) => {\n            args.push(this.execExpr(Q, T))\n        })\n        let result = this.funcs.run(id, args)\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprAttribute (Q, T) {\n        this.traceBegin(Q, T)\n        let id = Q.get(\"id\")\n        let result = this.adapter.getNodeAttrValue(T, id)\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprParam (Q, T) {\n        this.traceBegin(Q, T)\n        let id = Q.get(\"id\")\n        if (typeof this.params[id] === \"undefined\")\n            throw new Error(\"invalid parameter \\\"\" + id + \"\\\"\")\n        let result = this.params[id]\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprLiteralString (Q, T) {\n        this.traceBegin(Q, T)\n        let result = Q.get(\"value\")\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprLiteralRegExp (Q, T) {\n        this.traceBegin(Q, T)\n        let result = Q.get(\"value\")\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprLiteralNumber (Q, T) {\n        this.traceBegin(Q, T)\n        let result = Q.get(\"value\")\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprLiteralValue (Q, T) {\n        this.traceBegin(Q, T)\n        let result = Q.get(\"value\")\n        this.traceEnd(Q, T, result)\n        return result\n    }\n\n    execExprPath (Q, T) {\n        this.traceBegin(Q, T)\n        let result = this.execPath(Q, T)\n        this.traceEnd(Q, T, result)\n        return result\n    }\n}\n\nmodule.exports = ASTQQueryExec\n","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nlet ASTQAdapterASTY = {\n    taste (node) {\n        return (\n               typeof node      === \"object\"\n            && typeof node.ASTy === \"boolean\"\n        )\n    },\n    getParentNode (node) {\n        return node.parent()\n    },\n    getChildNodes (node) {\n        return node.childs()\n    },\n    getNodeType (node) {\n        return node.type()\n    },\n    getNodeAttrNames (node) {\n        return node.attrs()\n    },\n    getNodeAttrValue (node, attr) {\n        return node.get(attr)\n    }\n}\n\nmodule.exports = ASTQAdapterASTY\n\n","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* global __dirname: true */\n/* global console: true */\n\nlet ASTY     = require(\"asty\")\nlet PEG      = require(\"pegjs-otf\")\nlet PEGUtil  = require(\"pegjs-util\")\n\nlet ASTQQueryParse = PEG.buildParserFromFile(\n    __dirname + \"/astq-query-parse.pegjs\",\n    { optimize: \"speed\", cache: true }\n)\n\nlet ASTQQueryExec = require(\"./astq-query-exec.js\")\n\nlet ASTQQuery = class ASTQQuery {\n    constructor (selector) {\n        this.ast = null\n        if (selector)\n            this.compile(selector)\n    }\n    compile (selector, trace) {\n        if (trace)\n            console.log(\"ASTQ: compile: +-------------------------------------------------------------------------------------------------------\\n\" +\n                \"ASTQ: compile: | \" + selector)\n        let result = PEGUtil.parse(ASTQQueryParse, selector, {\n            startRule: \"query\",\n            makeAST: (line, column, offset, args) => {\n                return ASTY.apply(null, args).pos(line, column, offset)\n            }\n        })\n        if (result.error !== null)\n            throw new Error(\"ASTQ: compile: query parsing failed:\\n\" +\n                PEGUtil.errorMessage(result.error, true).replace(/^/mg, \"ERROR: \"))\n        this.ast = result.ast\n        if (trace)\n            console.log(\"ASTQ: compile: +-------------------------------------------------------------------------------------------------------\\n\" +\n                this.dump().replace(/\\n$/, \"\").replace(/^/mg, \"ASTQ: compile: | \"))\n        return this\n    }\n    dump () {\n        return this.ast.dump()\n    }\n    execute (node, adapter, params, funcs, trace) {\n        if (trace)\n            console.log(\"ASTQ: execute: +--------------------------------------------------------------+----------------------------------------\")\n        let qe = new ASTQQueryExec(adapter, params, funcs, trace)\n        return qe.execQuery(this.ast, node)\n    }\n}\n\nmodule.exports = ASTQQuery\n\n","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nclass ASTQCache {\n    constructor () {\n        this._index         = {}\n        this._oldHead       = { newer: null }\n        this._newHead       = { older: null }\n        this._oldHead.newer = this._newHead\n        this._newHead.older = this._oldHead\n        this._cur           = 0\n        this._max           = Infinity\n        this._dispose       = (/* key, val, op */) => {}\n        return this\n    }\n    limit (max) {\n        let maxOld = this._max\n        if (arguments.length > 0) {\n            this._max = max\n            this._purge()\n        }\n        return maxOld\n    }\n    dispose (cb) {\n        this._dispose = cb\n        return this\n    }\n    length () {\n        return this._cur\n    }\n    keys () {\n        return this.each(function (val, key) { this.push(key) }, [])\n    }\n    values () {\n        return this.each(function (val /*, key */) { this.push(val) }, [])\n    }\n    each (cb, ctx) {\n        if (arguments < 2)\n            ctx = this\n        let i = 0\n        let bucket = this._newHead.older\n        while (bucket !== this._oldHead) {\n            cb.call(ctx, bucket.val, bucket.key, i++)\n            bucket = bucket.older\n        }\n        return ctx\n    }\n    has (key) {\n        let bucket = this._index[key]\n        return (bucket !== undefined)\n    }\n    peek (key) {\n        let bucket = this._index[key]\n        if (bucket === undefined)\n            return undefined\n        if (bucket.expires < Date.now()) {\n            this.del(bucket.key)\n            return undefined\n        }\n        return bucket.val\n    }\n    touch (key) {\n        let bucket = this._index[key]\n        if (bucket !== undefined)\n            this._promote(bucket)\n        return this\n    }\n    get (key) {\n        let val = this.peek(key)\n        this.touch(key)\n        return val\n    }\n    set (key, val, expires) {\n        if (arguments.length < 3)\n            expires = Infinity\n        expires += Date.now()\n        let bucket = this._index[key]\n        if (bucket === undefined) {\n            /*  insert new bucket  */\n            bucket = {\n                older:   null,\n                newer:   null,\n                key:     key,\n                val:     val,\n                expires: expires \n            }\n            this._index[key] = bucket\n            this._attach(bucket)\n            this._cur++\n            this._purge()\n        }\n        else {\n            /*  replace existing bucket  */\n            let valOld = bucket.val\n            bucket.val = val\n            this._promote(bucket)\n            this._dispose(undefined, bucket.key, valOld, \"set\")\n        }\n        return this\n    }\n    del (key) {\n        let bucket = this._index[key]\n        if (bucket === undefined)\n            throw new Error(\"ASTQ::Cache#del: no such item\")\n        delete this._index[key]\n        this._detach(bucket)\n        this._cur--\n        this._dispose(undefined, key, bucket.val, \"del\")\n        return this\n    }\n    clear () {\n        while (this._cur > 0)\n            this.del(this._oldHead.newer.key)\n        return this\n    }\n    _purge () {\n        while (this._cur > this._max)\n            this.del(this._oldHead.newer.key)\n    }\n    _promote (bucket) {\n        /*  promote bucket to be MRU bucket  */\n        this._detach(bucket)\n        this._attach(bucket)\n    }\n    _detach (bucket) {\n        /*  detach bucket from list  */\n        bucket.older.newer = bucket.newer\n        bucket.newer.older = bucket.older\n        bucket.older       = null\n        bucket.newer       = null\n    }\n    _attach (bucket) {\n        /*  attach bucket to list as MRU bucket  */\n        bucket.older       = this._newHead.older\n        bucket.newer       = this._newHead\n        bucket.newer.older = bucket\n        bucket.older.newer = bucket\n    }\n}\n\nmodule.exports = ASTQCache\n\n","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nlet ASTQUtil = {\n    pad (str, num) {\n        if (num < 0)\n            return (str.length > -num ? str.substr(0, -num) : (str + Array((-num) + 1 - str.length).join(\" \")))\n        else\n            return (str.length > num ? str.substr(0, num) : Array(num + 1 - str.length).join(\" \") + str)\n    },\n    truthy (value) {\n        let result\n        switch (typeof value) {\n            case \"boolean\":\n                result = value\n                break\n            case \"number\":\n                result = (value !== 0 && !isNaN(value))\n                break\n            case \"string\":\n                result = (value !== \"\")\n                break\n            case \"object\":\n                result = false\n                if (value !== null) {\n                    result = true\n                    if (value instanceof Array)\n                        result = (value.length > 0)\n                }\n                break\n            default:\n                result = false\n        }\n        return result\n    },\n    coerce (value, type) {\n        let result\n        try {\n            switch (type) {\n                case \"boolean\":\n                    result = Boolean(value)\n                    break\n                case \"number\":\n                    result = Number(value)\n                    break\n                case \"string\":\n                    result = String(value)\n                    break\n                case \"regexp\":\n                    result = new RegExp(value)\n                    break\n                default:\n                    result = value\n            }\n        }\n        catch (e) {\n            throw new Error(\"cannot coerce value into type \" + type)\n        }\n        return result\n    }\n}\n\nmodule.exports = ASTQUtil\n","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nlet ASTQAdapter = require(\"./astq-adapter.js\")\nlet ASTQFuncs   = require(\"./astq-funcs.js\")\nlet ASTQCache   = require(\"./astq-cache.js\")\nlet ASTQQuery   = require(\"./astq-query.js\")\n\nlet ASTQ = class ASTQ {\n    constructor () {\n        if (!(this instanceof ASTQ))\n            return new ASTQ()\n        this._adapter = new ASTQAdapter()\n        this._funcs   = new ASTQFuncs()\n        this._cache   = new ASTQCache()\n    }\n    adapter (adapter) {\n        if (arguments.length !== 1)\n            throw new Error(\"ASTQ#adapter: invalid number of arguments\")\n        this._adapter.register(adapter)\n        return this\n    }\n    func (name, func) {\n        if (arguments.length !== 2)\n            throw new Error(\"ASTQ#func: invalid number of arguments\")\n        this._funcs.register(name, func)\n        return this\n    }\n    cache (entries) {\n        if (arguments.length !== 1)\n            throw new Error(\"ASTQ#cache: invalid number of arguments\")\n        this._cache.limit(entries)\n        return this\n    }\n    compile (selector, trace) {\n        if (arguments.length < 1)\n            throw new Error(\"ASTQ#compile: too less arguments\")\n        if (arguments.length > 2)\n            throw new Error(\"ASTQ#compile: too many arguments\")\n        if (trace === undefined)\n            trace = false\n        let query = this._cache.get(selector)\n        if (query === undefined) {\n            query = new ASTQQuery()\n            query.compile(selector, trace)\n            this._cache.set(selector, query)\n        }\n        return query\n    }\n    execute (node, query, params, trace) {\n        if (arguments.length < 2)\n            throw new Error(\"ASTQ#execute: too less arguments\")\n        if (arguments.length > 4)\n            throw new Error(\"ASTQ#execute: too many arguments\")\n        if (params === undefined)\n            params = {}\n        if (trace === undefined)\n            trace = false\n        let adapter = this._adapter.select(node)\n        if (adapter === undefined)\n            throw new Error(\"ASTQ#execute: no suitable adapter found for node\")\n        return query.execute(node, adapter, params, this._funcs, trace)\n    }\n    query (node, selector, params, trace) {\n        if (arguments.length < 2)\n            throw new Error(\"ASTQ#query: too less arguments\")\n        if (arguments.length > 4)\n            throw new Error(\"ASTQ#query: too many arguments\")\n        if (params === undefined)\n            params = {}\n        if (trace === undefined)\n            trace = false\n        return this.execute(node, this.compile(selector, trace), params, trace)\n    }\n}\n\nmodule.exports = ASTQ\n\n","/*\n**  ASTq -- Abstract Syntax Tree (AST) Query Engine\n**  Copyright (c) 2014-2015 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nlet stdfuncs = require(\"./astq-funcs-std.js\")\n\nclass ASTQFuncs {\n    constructor () {\n        this._funcs = {}\n        for (let name in stdfuncs)\n            this.register(name, stdfuncs[name])\n        return this\n    }\n    register (name, func) {\n        this._funcs[name] = func\n    }\n    run (name, args) {\n        let func = this._funcs[name]\n        if (typeof func !== \"function\")\n            throw new Error(\"invalid function \\\"\" + name + \"\\\"\")\n        return func.apply(null, args)\n    }\n}\n\nmodule.exports = ASTQFuncs\n","/*\n**  pegjs-util -- Utility Class for PEG.js\n**  Copyright (c) 2014 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*  Universal Module Definition (UMD) for Library  */\n(function (root, name, factory) {\n    /* global define: false */\n    /* global module: false */\n    if (typeof define === \"function\" && typeof define.amd !== \"undefined\")\n        /*  AMD environment  */\n        define(name, function () { return factory(root); });\n    else if (typeof module === \"object\" && typeof module.exports === \"object\")\n        /*  CommonJS environment  */\n        module.exports = factory(root);\n    else\n        /*  Browser environment  */\n        root[name] = factory(root);\n}(/* global global: false */\n  (typeof global !== \"undefined\" ? global :\n  /* global window: false */\n  (typeof window !== \"undefined\" ? window : this)), \"PEGUtil\", function (/* root */) {\n\n    var PEGUtil = {};\n\n    /*  helper function for generating a function to generate an AST node  */\n    PEGUtil.makeAST = function makeAST (line, column, offset, options) {\n        return function () {\n            return options.util.__makeAST.call(null, line(), column(), offset(), arguments);\n        };\n    };\n\n    /*  helper function for generating a function to unroll the parse stack  */\n    PEGUtil.makeUnroll = function (line, column, offset, SyntaxError) {\n        return function (first, list, take) {\n            if (   typeof list !== \"object\"\n                || !(list instanceof Array))\n                throw new SyntaxError(\"unroll: invalid list argument for unrolling\",\n                    (typeof list), \"Array\", offset(), line(), column());\n            if (typeof take !== \"undefined\") {\n                if (typeof take === \"number\")\n                    take = [ take ];\n                var result = [];\n                if (first !== null)\n                    result.push(first);\n                for (var i = 0; i < list.length; i++) {\n                    for (var j = 0; j < take.length; j++)\n                        result.push(list[i][take[j]]);\n                }\n                return result;\n            }\n            else {\n                if (first !== null)\n                    list.unshift(first);\n                return list;\n            }\n        };\n    };\n\n    /*  utility function: create a source excerpt  */\n    var excerpt = function (txt, o) {\n        var l = txt.length;\n        var b = o - 20; if (b < 0) b = 0;\n        var e = o + 20; if (e > l) e = l;\n        var hex = function (ch) {\n            return ch.charCodeAt(0).toString(16).toUpperCase();\n        };\n        var extract = function (txt, pos, len) {\n            return txt.substr(pos, len)\n                .replace(/\\\\/g,   \"\\\\\\\\\")\n                .replace(/\\x08/g, \"\\\\b\")\n                .replace(/\\t/g,   \"\\\\t\")\n                .replace(/\\n/g,   \"\\\\n\")\n                .replace(/\\f/g,   \"\\\\f\")\n                .replace(/\\r/g,   \"\\\\r\")\n                .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return \"\\\\x0\" + hex(ch); })\n                .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return \"\\\\x\"  + hex(ch); })\n                .replace(/[\\u0100-\\u0FFF]/g,         function(ch) { return \"\\\\u0\" + hex(ch); })\n                .replace(/[\\u1000-\\uFFFF]/g,         function(ch) { return \"\\\\u\"  + hex(ch); });\n        };\n        return {\n            prolog: extract(txt, b, o - b),\n            token:  extract(txt, o, 1),\n            epilog: extract(txt, o + 1, e - (o + 1))\n        };\n    };\n\n    /*  provide top-level parsing functionality  */\n    PEGUtil.parse = function (parser, txt, options) {\n        if (typeof parser !== \"object\")\n            throw new Error(\"invalid parser object (not an object)\");\n        if (typeof parser.parse !== \"function\")\n            throw new Error(\"invalid parser object (no \\\"parse\\\" function)\");\n        if (typeof txt !== \"string\")\n            throw new Error(\"invalid input text (not a string)\");\n        if (typeof options !== \"undefined\" && typeof options !== \"object\")\n            throw new Error(\"invalid options (not an object)\");\n        if (typeof options === \"undefined\")\n            options = {};\n        var result = { ast: null, error: null };\n        try {\n            var makeAST;\n            if (typeof options.makeAST === \"function\")\n                makeAST = options.makeAST;\n            else {\n                makeAST = function (line, column, offset, args) {\n                    return { line: line, column: column, offset: offset, args: args };\n                };\n            }\n            var opts = {\n                util: {\n                    makeUnroll: PEGUtil.makeUnroll,\n                    makeAST:    PEGUtil.makeAST,\n                    __makeAST:  makeAST\n                }\n            };\n            if (typeof options.startRule === \"string\")\n                opts.startRule = options.startRule;\n            result.ast = parser.parse(txt, opts);\n            result.error = null;\n        }\n        catch (e) {\n            result.ast = null;\n            var definedOrElse = function (value, fallback) {\n                return (typeof value !== \"undefined\" ? value : fallback);\n            };\n            result.error = {\n                line:     definedOrElse(e.line, 0),\n                column:   definedOrElse(e.column, 0),\n                message:  e.message,\n                found:    definedOrElse(e.found, \"\"),\n                expected: definedOrElse(e.expected, \"\"),\n                location: excerpt(txt, definedOrElse(e.offset, 0))\n            };\n        }\n        return result;\n    };\n\n    /*  render a useful error message  */\n    PEGUtil.errorMessage = function (e, noFinalNewline) {\n        var l = e.location;\n        var prefix1 = \"line \" + e.line + \" (column \" + e.column + \"): \";\n        var prefix2 = \"\";\n        for (var i = 0; i < prefix1.length + l.prolog.length; i++)\n            prefix2 += \"-\";\n        var msg = prefix1 + l.prolog + l.token + l.epilog + \"\\n\" +\n            prefix2 + \"^\" + \"\\n\" +\n            e.message + (noFinalNewline ? \"\" : \"\\n\");\n        return msg;\n    };\n\n    return PEGUtil;\n}));\n\n"]}